<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dashboard Unreal HUD</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
:root{
  --bg:#05060a;
  --panel:#0b1020;
  --panel2:#0a0f1c;
  --border: rgba(120, 140, 255, 0.18);
  --text:#e6eaff;
  --muted:#9aa4c7;

  --cyan:#2ef2ff;
  --purple:#8b5cf6;
  --green:#00e676;
  --red:#ff3b3b;

  --shadow: 0 0 24px rgba(46, 242, 255, 0.10);
  --radius:16px;
  --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

*{ box-sizing:border-box; }

html, body{
  margin:0;
  height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:var(--font);
  overflow:hidden;
}

.hud{
  position: fixed;
  top: 0;
  right: 0;
  height: 100vh;
  width: 33.3333vw;
  min-width: 360px;
  max-width: 520px;
  padding: 14px;

  display: flex;
  flex-direction: column;
  gap: 12px;

  background: linear-gradient(180deg, rgba(11,16,32,0.98), rgba(5,6,10,0.98));
  border-left: 1px solid rgba(46,242,255,0.18);
  box-shadow: -18px 0 40px rgba(0,0,0,0.55);
  backdrop-filter: blur(8px);
}

.header{
  background: linear-gradient(135deg, rgba(46,242,255,0.08), rgba(139,92,246,0.06));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  box-shadow: var(--shadow);
}

.titleRow{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
}

h2{
  margin:0;
  font-size: 14px;
  letter-spacing: 0.6px;
  font-weight: 800;
  text-transform: uppercase;
}

.sub{
  margin-top: 4px;
  font-size: 11px;
  color: var(--muted);
}

.badge{
  font-size: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(46,242,255,0.22);
  background: rgba(46,242,255,0.06);
  color: var(--cyan);
  white-space: nowrap;
}

.kpiHeader{
  margin-top: 10px;
  display:flex;
  flex-direction:column;
  gap:4px;
}

.kpiValue{
  font-size: 16px;
  font-weight: 900;
  letter-spacing: 0.2px;
  text-shadow: 0 0 14px rgba(46,242,255,0.08);
}

.kpiRef{
  font-size: 11px;
  color: var(--muted);
}

/* NUEVO: sensor id arriba */
.sensorIdTop{
  font-size: 10px;
  color: rgba(46,242,255,0.85);
  letter-spacing: 0.3px;
  margin-top: 2px;
}

.panel{
  background: linear-gradient(180deg, rgba(10,15,28,0.98), rgba(8,10,18,0.98));
  border: 1px solid rgba(120, 140, 255, 0.16);
  border-radius: var(--radius);
  padding: 12px;
  box-shadow: 0 0 22px rgba(0,0,0,0.45);
}

.controls{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}

.controls2{
  margin-top:10px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}

label{
  font-size:10px;
  color: var(--muted);
  display:block;
  margin-bottom:6px;
  text-transform: uppercase;
  letter-spacing:0.3px;
}

.dateField{
  position: relative;
}

.dateField input[type="date"]{
  width:100%;
  padding:10px 38px 10px 10px;
  border-radius: 14px;
  border: 1px solid rgba(46,242,255,0.18);
  background: rgba(3,6,12,0.65);
  color: var(--text);
  font-size: 12px;
  outline:none;
}

.dateField input[type="date"]:focus{
  border-color: rgba(46,242,255,0.45);
  box-shadow: 0 0 0 3px rgba(46,242,255,0.10);
}

.dateIconBtn{
  position:absolute;
  top:50%;
  right:10px;
  transform: translateY(-50%);
  width: 26px;
  height: 26px;
  border-radius: 10px;
  border: 1px solid rgba(46,242,255,0.18);
  background: rgba(46,242,255,0.06);
  color: var(--cyan);
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 14px;
}

select{
  width:100%;
  padding:10px 10px;
  border-radius: 14px;
  border: 1px solid rgba(46,242,255,0.18);
  background: rgba(3,6,12,0.65);
  color: var(--text);
  font-size: 12px;
  outline:none;
}

select:focus{
  border-color: rgba(46,242,255,0.45);
  box-shadow: 0 0 0 3px rgba(46,242,255,0.10);
}

#metrics{
  display:grid;
  grid-template-columns: repeat(5, 1fr);
  gap:8px;
}

.metric{
  border: 1px solid rgba(46,242,255,0.12);
  border-radius: 14px;
  padding: 10px;
  background: rgba(3,6,12,0.55);
}

.metric b{
  display:block;
  font-size: 10px;
  color: var(--muted);
  font-weight: 700;
  margin-bottom: 6px;
  letter-spacing: 0.2px;
  text-transform: uppercase;
}

.metric span{
  font-size: 14px;
  font-weight: 900;
}

.metric small{
  display:block;
  margin-top: 6px;
  color: var(--muted);
  font-size: 10px;
}

.canvasWrap{
  flex: 1;
  min-height: 240px;
  display:flex;
  flex-direction:column;
  gap:10px;
  overflow:hidden;
}

.chartTitle{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  color: var(--muted);
  font-size: 11px;
}

.chartBox{
  flex: 1;
  min-height: 220px;
  position: relative;
}

canvas{
  position:absolute;
  inset:0;
  width:100% !important;
  height:100% !important;

  background: rgba(3,6,12,0.55);
  border: 1px solid rgba(46,242,255,0.12);
  border-radius: var(--radius);
  padding: 10px;
}

.exportBtn{
  padding: 6px 10px;
  font-size: 10px;
  border-radius: 999px;
  cursor: pointer;
  border: 1px solid rgba(46,242,255,0.22);
  background: rgba(46,242,255,0.06);
  color: var(--cyan);
  text-transform: uppercase;
  letter-spacing: 0.4px;
}

.exportBtn:hover{
  border-color: rgba(46,242,255,0.45);
  box-shadow: 0 0 0 3px rgba(46,242,255,0.10);
}

@media (max-width: 980px){
  .hud{
    width: 100vw;
    max-width: none;
    min-width: 0;
  }
  #metrics{
    grid-template-columns: repeat(2, 1fr);
  }
}
</style>
</head>

<body>

<div class="hud">

  <div class="header">
    <div class="titleRow">
      <div>
        <h2>Building Monitor</h2>
        <div class="sub">Live telemetry HUD</div>
        <!-- NUEVO -->
        <div id="sensorIdTop" class="sensorIdTop">Sensor: --</div>
      </div>
      <div class="badge">UNREAL HUD</div>
    </div>

    <div class="kpiHeader">
      <div id="energiaHoy" class="kpiValue">--</div>
      <div id="energiaRef" class="kpiRef">Referencia: --</div>
    </div>
  </div>

  <div class="panel">
    <div class="controls">
      <div>
        <label>Sensor</label>
        <select id="sensorSelect"></select>
      </div>

      <div>
        <label>Resoluci√≥n</label>
        <select id="resolutionSelect">
          <option value="15m">15 min</option>
          <option value="1h">Hora</option>
          <option value="1d">D√≠a</option>
        </select>
      </div>
    </div>

    <div class="controls2">
      <div>
        <label>CONSULTA FECHA INICIO</label>
        <div class="dateField">
          <input type="date" id="dateStart">
          <button class="dateIconBtn" type="button" onclick="openCalendar('dateStart')" title="Abrir calendario">üìÖ</button>
        </div>
      </div>

      <div>
        <label>CONSULTA FECHA FINAL</label>
        <div class="dateField">
          <input type="date" id="dateEnd">
          <button class="dateIconBtn" type="button" onclick="openCalendar('dateEnd')" title="Abrir calendario">üìÖ</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <div id="metrics"></div>
  </div>

  <div class="panel canvasWrap">
    <div class="chartTitle">
      <div id="chartLabel">Serie temporal</div>

      <div style="display:flex; gap:8px; align-items:center;">
        <button class="exportBtn" onclick="exportData('csv')">CSV</button>
        <button class="exportBtn" onclick="exportData('json')">JSON</button>
        <div style="color: var(--cyan);">‚óè LIVE</div>
      </div>
    </div>

    <div class="chartBox">
      <canvas id="chart"></canvas>
    </div>
  </div>

</div>

<script>
let chart = null;
let currentSensorData = null;
let sensoresMap = {}; // NUEVO: guardamos √≠ndice para saber unidad y sensor_id

const INDEX_FILE = "indice_sensores.json";
const DATA_FOLDER = "datos_sensores";

/* KPI placeholder */
function updateHeaderEnergiaImportada() {
  document.getElementById("energiaHoy").textContent = "Energ√≠a hoy: --";
  document.getElementById("energiaRef").textContent = "Referencia (10 laborables): --";
}

/* NUEVO: sensor id arriba */
function updateSensorIdTop(sensorId) {
  document.getElementById("sensorIdTop").textContent = sensorId ? `Sensor: ${sensorId}` : "Sensor: --";
}

/* Calendario */
function openCalendar(inputId) {
  const el = document.getElementById(inputId);
  if (!el) return;
  if (typeof el.showPicker === "function") el.showPicker();
  else { el.focus(); el.click(); }
}

/* Fechas */
function toISODateLocal(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}
function startOfDay(dateObj) {
  const d = new Date(dateObj);
  d.setHours(0,0,0,0);
  return d;
}
function endOfDay(dateObj) {
  const d = new Date(dateObj);
  d.setHours(23,59,59,999);
  return d;
}
function filterByDates(labels, values, dateStart, dateEnd) {
  const from = startOfDay(new Date(dateStart));
  const to = endOfDay(new Date(dateEnd));

  const outLabels = [];
  const outValues = [];

  labels.forEach((l, i) => {
    const t = new Date(l);
    if (t >= from && t <= to) {
      outLabels.push(l);
      outValues.push(values[i]);
    }
  });

  return { outLabels, outValues };
}

/* Agregaci√≥n */
function bucketKey(dateObj, resolution) {
  const y = dateObj.getFullYear();
  const m = String(dateObj.getMonth()+1).padStart(2, "0");
  const d = String(dateObj.getDate()).padStart(2, "0");
  const hh = String(dateObj.getHours()).padStart(2, "0");

  if (resolution === "1d") return `${y}-${m}-${d}`;
  if (resolution === "1h") return `${y}-${m}-${d} ${hh}:00`;
  return dateObj.toISOString();
}

function aggregateSeries(labels, values, resolution, tipo) {
  if (resolution === "15m") return { labels, values };

  const map = new Map();

  labels.forEach((l, i) => {
    const t = new Date(l);
    const key = bucketKey(t, resolution);

    if (!map.has(key)) map.set(key, { sum: 0, count: 0 });
    const obj = map.get(key);

    obj.sum += values[i];
    obj.count += 1;
  });

  const outLabels = [];
  const outValues = [];

  for (const [key, obj] of map.entries()) {
    outLabels.push(key);
    if (tipo === "consumo_intervalo") outValues.push(obj.sum);
    else outValues.push(obj.sum / obj.count);
  }

  return { labels: outLabels, values: outValues };
}

/* M√©tricas */
function calcMetrics(labels, values, tipo) {
  if (!values.length) return {};

  const max = Math.max(...values);
  const min = Math.min(...values);
  const sumaTotal = values.reduce((a, b) => a + b, 0);

  let actual, media, suma;

  if (tipo === "consumo_intervalo") {
    actual = values[values.length - 1];
    const dias = new Set(labels.map(l => String(l).slice(0, 10))).size;
    media  = dias ? sumaTotal / dias : 0;
    suma   = sumaTotal;
  } else {
    actual = values[values.length - 1];
    media  = sumaTotal / values.length;
    suma   = null;
  }

  return { actual, max, min, media, suma };
}

function renderMetrics(m, unidad) {
  const fmt = v => (v === null || v === undefined) ? "--" : v.toFixed(2);

  document.getElementById("metrics").innerHTML = `
    <div class="metric"><b>Actual</b><span>${fmt(m.actual)}</span><small>${m.actual != null ? unidad : ""}</small></div>
    <div class="metric"><b>M√°ximo</b><span>${fmt(m.max)}</span><small>${unidad}</small></div>
    <div class="metric"><b>M√≠nimo</b><span>${fmt(m.min)}</span><small>${unidad}</small></div>
    <div class="metric"><b>Media</b><span>${fmt(m.media)}</span><small>${m.media != null ? unidad : ""}</small></div>
    <div class="metric"><b>Suma</b><span>${fmt(m.suma)}</span><small>${m.suma != null ? unidad : ""}</small></div>
  `;
}

/* Chart */
function drawChart(labels, values, titulo) {
  const ctx = document.getElementById("chart").getContext("2d");
  if (chart) chart.destroy();

  document.getElementById("chartLabel").textContent = titulo;

  const maxVal = Math.max(...values);
  const minVal = Math.min(...values);
  const meanVal = values.reduce((a,b)=>a+b,0) / values.length;

  const idxMax = values.indexOf(maxVal);
  const idxMin = values.indexOf(minVal);

  const maxPoints = values.map((v, i) => i === idxMax ? v : null);
  const minPoints = values.map((v, i) => i === idxMin ? v : null);
  const meanLine  = values.map(() => meanVal);

  chart = new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [
        { label: titulo, data: values, borderWidth: 2, fill: false, pointRadius: 0 },
        { label: "Media", data: meanLine, borderWidth: 1, borderDash: [6, 6], pointRadius: 0 },
        { label: "M√°ximo", data: maxPoints, showLine: false, pointRadius: 6, pointHoverRadius: 8 },
        { label: "M√≠nimo", data: minPoints, showLine: false, pointRadius: 6, pointHoverRadius: 8 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { intersect: false, mode: "index" },
      plugins: { legend: { labels: { color: "#9aa4c7" } } },
      scales: {
        x: { ticks: { color: "#9aa4c7", maxRotation: 0 } },
        y: { ticks: { color: "#9aa4c7" } }
      }
    }
  });
}

/* Export */
function downloadFile(filename, content, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();

  URL.revokeObjectURL(url);
}

function getCurrentFilteredData() {
  if (!currentSensorData) return null;

  const dateStart = document.getElementById("dateStart").value;
  const dateEnd = document.getElementById("dateEnd").value;
  const resolution = document.getElementById("resolutionSelect").value;

  const filtered = filterByDates(
    currentSensorData.labels,
    currentSensorData.values,
    dateStart,
    dateEnd
  );

  const aggregated = aggregateSeries(
    filtered.outLabels,
    filtered.outValues,
    resolution,
    currentSensorData.tipo_dato
  );

  return {
    sensor_id: currentSensorData.sensor_id,
    descripcion: currentSensorData.descripcion,
    unidad: currentSensorData.unidad,
    tipo_dato: currentSensorData.tipo_dato,
    resolution,
    dateStart,
    dateEnd,
    points: aggregated.labels.map((l, i) => ({
      timestamp: l,
      value: aggregated.values[i]
    }))
  };
}

function exportData(format) {
  const data = getCurrentFilteredData();
  if (!data || !data.points.length) {
    alert("No hay datos para exportar en el rango seleccionado.");
    return;
  }

  const safeName = data.sensor_id.replace(/[^a-zA-Z0-9_-]/g, "_");
  const filenameBase = `${safeName}_${data.dateStart}_${data.dateEnd}_${data.resolution}`;

  if (format === "json") {
    downloadFile(`${filenameBase}.json`, JSON.stringify(data, null, 2), "application/json");
    return;
  }

  const header = ["timestamp","value","unidad","sensor_id","descripcion"].join(",");
  const rows = data.points.map(p => {
    const ts = `"${p.timestamp}"`;
    const val = (p.value ?? "").toString();
    const unidad = `"${data.unidad}"`;
    const id = `"${data.sensor_id}"`;
    const desc = `"${data.descripcion.replace(/"/g, '""')}"`;
    return [ts, val, unidad, id, desc].join(",");
  });

  downloadFile(`${filenameBase}.csv`, [header, ...rows].join("\n"), "text/csv");
}

/* ======================================================
   CARGA REAL (tu √≠ndice real)
====================================================== */
async function loadIndex() {
  const res = await fetch(INDEX_FILE, { cache: "no-store" });
  if (!res.ok) throw new Error("No se pudo cargar " + INDEX_FILE);
  return await res.json();
}

async function loadSensorByFile(fileName) {
  const path = `${DATA_FOLDER}/${fileName}`;
  const res = await fetch(path, { cache: "no-store" });
  if (!res.ok) throw new Error("No se pudo cargar " + path);
  return await res.json();
}

function setDefaultLast2Days() {
  const now = new Date();
  const end = toISODateLocal(now);
  const start = new Date(now.getTime() - 1 * 86400000);
  document.getElementById("dateStart").value = toISODateLocal(start);
  document.getElementById("dateEnd").value = end;
}

function redraw() {
  if (!currentSensorData) return;

  const dateStart = document.getElementById("dateStart").value;
  const dateEnd = document.getElementById("dateEnd").value;
  const resolution = document.getElementById("resolutionSelect").value;

  const filtered = filterByDates(currentSensorData.labels, currentSensorData.values, dateStart, dateEnd);
  const aggregated = aggregateSeries(filtered.outLabels, filtered.outValues, resolution, currentSensorData.tipo_dato);

  if (!aggregated.values.length) {
    renderMetrics({}, currentSensorData.unidad);
    return;
  }

  drawChart(aggregated.labels, aggregated.values, currentSensorData.descripcion);

  const metrics = calcMetrics(aggregated.labels, aggregated.values, currentSensorData.tipo_dato);
  renderMetrics(metrics, currentSensorData.unidad);
}

async function initAppReal() {
  const select = document.getElementById("sensorSelect");
  select.innerHTML = "";

  const index = await loadIndex();

  const sensoresObj = index.sensores || {};
  sensoresMap = sensoresObj;

  const sensoresList = Object.entries(sensoresObj).map(([id, meta]) => ({
    id,
    ...meta
  }));

  sensoresList.sort((a,b) => a.descripcion.localeCompare(b.descripcion));

  sensoresList.forEach(s => {
    const opt = document.createElement("option");
    opt.value = s.archivo;

    // ‚úÖ MEJORA 1: descripci√≥n + unidad
    const unitText = s.unidad ? ` (${s.unidad})` : "";
    opt.textContent = `${s.descripcion}${unitText}`;

    // guardamos el id para poder recuperarlo r√°pido
    opt.dataset.sensorId = s.id;

    select.appendChild(opt);
  });

  setDefaultLast2Days();
  document.getElementById("resolutionSelect").value = "15m";

  select.onchange = async () => {
    const selectedOpt = select.options[select.selectedIndex];
    const sensorId = selectedOpt?.dataset?.sensorId;

    // ‚úÖ MEJORA 2: sensor_id arriba
    updateSensorIdTop(sensorId);

    currentSensorData = await loadSensorByFile(select.value);

    // Por si el JSON no trae sensor_id (seguridad)
    if (!currentSensorData.sensor_id && sensorId) {
      currentSensorData.sensor_id = sensorId;
    }

    redraw();
  };

  document.getElementById("dateStart").onchange = redraw;
  document.getElementById("dateEnd").onchange = redraw;
  document.getElementById("resolutionSelect").onchange = redraw;

  // carga inicial
  const selectedOpt = select.options[select.selectedIndex];
  const sensorId = selectedOpt?.dataset?.sensorId;
  updateSensorIdTop(sensorId);

  currentSensorData = await loadSensorByFile(select.value);
  if (!currentSensorData.sensor_id && sensorId) currentSensorData.sensor_id = sensorId;

  redraw();
  updateHeaderEnergiaImportada();
}

initAppReal().catch(err => {
  console.error(err);
  alert("Error cargando datos reales. Revisa indice_sensores.json y datos_sensores/");
});
</script>

</body>
</html>
